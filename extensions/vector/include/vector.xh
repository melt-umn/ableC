#include <string.xh>
#include <gc.h>

#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
//#include <limits.h>

#ifndef _VECTOR_XH
#define _VECTOR_XH

struct _vector_info {
  size_t length;
  size_t capacity;
  size_t elem_size;
};

template<a>
struct __attribute__((module("edu:umn:cs:melt:exts:ableC:vector:vector"))) _vector_s {
  struct _vector_info *_info;
  a **_contents;
};

// Check whether an index is valid for given vector info
template<a>
static void _check_index_vector(vector<a> vec, size_t i) {
  if (i >= vec.length || i < 0) {
    fprintf(stderr, "Vector index out of bounds: length %lu, index %lu\n", vec.length, i);
    exit(1);
  }
  if (vec._contents == NULL) {
    fprintf(stderr, "Cannot access uninitialized vector\n");
    exit(1);
  }
}

// Increase the length of a vector to new_size, updating the given info and contents pointers
template<a>
static void _resize_vector(vector<a> vec, size_t new_length) {
  vec._info->length = new_length;
  if (new_length > vec.capacity) {
    vec._info->capacity = new_length * 2;
    *vec._contents = GC_realloc(*vec._contents, vec.elem_size * vec.capacity);
  }
}

// If the index is equal to the vector size, expand the vector by one
template<a>
static void _maybe_grow_vector_by_one(vector<a> vec, size_t i) {
  if (i > vec.length || i < 0) {
    fprintf(stderr, "Vector index out of bounds: length %lu, index %lu\n", vec.length, i);
    exit(1);
  }
  if (i == vec.length) {
    _resize_vector<a>(vec, vec.length + 1);
  }
}

template<a>
static vector<a> _new_vector(size_t length) {
  struct _vector_info *info = GC_malloc(sizeof(struct _vector_info));
  info->length = length;
  info->capacity = length * 2;
  info->elem_size = sizeof(a);
  a **contents = GC_malloc(sizeof(a*));
  *contents = GC_malloc(sizeof(a) * info->capacity);
  return (vector<a>){info, contents};
}

template<a>
static vector<a> _copy_vector(vector<a> vec) {
  struct _vector_info *info = GC_malloc(sizeof(struct _vector_info));
  *info = *vec._info;
  a **contents = GC_malloc(sizeof(a*));
  *contents = GC_malloc(vec.elem_size * vec.capacity);
  
  for (size_t i = 0; i < vec.length; i++) {
    (*contents)[i] = vec[i];
  }
  
  return (vector<a>){info, contents};
}

template<a>
static vector<a> _append_to_vector(vector<a> vec1, vector<a> vec2) {
  size_t vec1_length = vec1.length;

  for (size_t i = 0; i < vec2.length; i++) {
    vec1[i + vec1_length] = vec2[i];
  }
  
  return vec1;
}

template<a>
static bool _eq_vector(vector<a> vec1, vector<a> vec2) {
  if (vec1.length != vec2.length)
    return 0;

  for (size_t i = 0; i < vec1.length; i++) {
    if (vec1[i] != vec2[i])
      return 0;
  }
  
  return 1;
}

template<a>
static string _show_vector(vector<a> vec) {
  if (vec.length == 0)
    return str("[]");
    
  string result = "[" + show(vec[0]);
  
  for (size_t i = 1; i < vec.length; i++) {
    result += ", " + show(vec[i]);
  }
  
  return result + "]";
}

#endif
